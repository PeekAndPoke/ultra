@file:Suppress("detekt:ReturnCount")

package de.peekandpoke.mutator.ksp.builtin

import com.google.devtools.ksp.getDeclaredProperties
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSDeclaration
import com.google.devtools.ksp.symbol.KSPropertyDeclaration
import de.peekandpoke.mutator.ksp.GenericsUtil
import de.peekandpoke.mutator.ksp.MutatorCodeBlocks.Companion.ListMutatorName
import de.peekandpoke.mutator.ksp.MutatorCodeBlocks.Companion.MapMutatorName
import de.peekandpoke.mutator.ksp.MutatorCodeBlocks.Companion.ObjectMutatorName
import de.peekandpoke.mutator.ksp.MutatorCodeBlocks.Companion.SetMutatorName
import de.peekandpoke.mutator.ksp.MutatorKspPlugin
import de.peekandpoke.mutator.ksp.MutatorKspPlugin.MutatorGeneratorContext
import de.peekandpoke.mutator.ksp.MutatorKspPlugins
import de.peekandpoke.mutator.ksp.MutatorKspProcessor
import de.peekandpoke.mutator.ksp.declaresKotlinList
import de.peekandpoke.mutator.ksp.declaresKotlinMap
import de.peekandpoke.mutator.ksp.declaresKotlinSet
import de.peekandpoke.mutator.ksp.isData
import de.peekandpoke.mutator.ksp.isPrimaryCtorParameter
import de.peekandpoke.mutator.ksp.isSealed

class BuiltInMutableObjectsPlugin : MutatorKspPlugin {

    override val name = "BuiltIn: Mutable Objects Plugin"

    override fun generatesMutatorFor(
        processor: MutatorKspProcessor,
        declaration: KSDeclaration,
        plugins: MutatorKspPlugins,
    ): Boolean {
        if (declaration !is KSClassDeclaration) return false

        return declaration.isData() || declaration.isSealed()
    }

    override fun generatesMutatorFieldFor(
        processor: MutatorKspProcessor,
        property: KSPropertyDeclaration,
        plugins: MutatorKspPlugins,
    ): Boolean {
        val type = property.type.resolve()
        val decl = type.declaration

        if (decl !is KSClassDeclaration) return false

        if (decl.isData() || decl.isSealed()) return true

        if (isSupportedCollection(property, plugins)) return true
        if (isSupportedMap(property, plugins)) return true

        return false
    }

    override fun generateMutatorFor(
        processor: MutatorKspProcessor,
        ctx: MutatorGeneratorContext,
    ) {
        val cls = ctx.cls
        val codeBlocks = ctx.codeBlocks
        val plugins = ctx.plugins

        val clsName = codeBlocks.getClassNameWithTypeParams(cls)
        val clsNameStar = codeBlocks.getClassNameStarProjection(cls)

        val typeParamsWithBounds = codeBlocks.getTypeParamsWithBounds(cls)
        val typeParams = typeParamsWithBounds?.plus(" ") ?: ""
        val mapTypeParams = if (typeParamsWithBounds == null) {
            "<K> "
        } else {
            val innerParams = typeParamsWithBounds.removeSurrounding("<", ">")
            "<K, $innerParams> "
        }

        codeBlocks.append("// Mutator for data class $clsName (${cls.qualifiedName?.asString()})")
        codeBlocks.append("// Generated by the '${this.name}' plugin")

        val allFields = cls.getDeclaredProperties()
        val ctorFields = allFields.filter { it.isPrimaryCtorParameter() }

        val boundObjectMutatorName = "$ObjectMutatorName<$clsName>"

        codeBlocks.append(
            """
                // Mutator creators ////////////////////////////////////////////////////////////////////////////////////
                
                @MutatorDsl
                inline fun $typeParams$clsName.mutator() = $ObjectMutatorName(this)
                
                @MutatorDsl
                inline fun $typeParams$clsName.mutate(
                    mutation: $boundObjectMutatorName.() -> Unit,
                ): $clsName = mutator().apply(mutation).get()

                // List Mutators ///////////////////////////////////////////////////////////////////////////////////////

                @MutatorDsl
                inline fun ${typeParams}List<$clsName>.mutator() = mutator(child = { mutator() })
                
                @MutatorDsl
                inline fun ${typeParams}List<$clsName>.mutate(
                    mutation: $ListMutatorName<$clsName>.() -> Unit,
                ): List<$clsName> = mutator().apply(mutation).get()

                /**
                 * Returns a list containing only the mutators whose underlying value is an instance of specified type parameter [X].
                 */
                @MutatorDsl
                inline fun <reified X : $clsNameStar> ListMutator<$clsNameStar>.filterMutatorsOf(): List<Mutator<X>> {
                    return mapNotNull { mutator ->
                        if (mutator.get() is X) {
                            @Suppress("UNCHECKED_CAST")
                            mutator as Mutator<X>
                        } else {
                            null
                        }
                    }
                }

                // Set Mutators ////////////////////////////////////////////////////////////////////////////////////////

                @MutatorDsl
                inline fun ${typeParams}Set<$clsName>.mutator() = mutator(child = { mutator() })

                @MutatorDsl
                inline fun ${typeParams}Set<$clsName>.mutate(
                    mutation: $SetMutatorName<$clsName>.() -> Unit,
                ): Set<$clsName> = mutator().apply(mutation).get()
                
                /**
                 * Returns a list containing only the mutators whose underlying value is an instance of specified type parameter [X].
                 */
                @MutatorDsl
                inline fun <reified X : $clsNameStar> SetMutator<$clsNameStar>.filterMutatorsOf(): List<Mutator<X>> {
                    return mapNotNull { mutator ->
                        if (mutator.get() is X) {
                            @Suppress("UNCHECKED_CAST")
                            mutator as Mutator<X>
                        } else {
                            null
                        }
                    }
                }

                // Map Mutators ////////////////////////////////////////////////////////////////////////////////////////
                
                @MutatorDsl
                inline fun ${mapTypeParams}Map<K, $clsName>.mutator() = mutator(child = { mutator() })

                @MutatorDsl
                inline fun ${mapTypeParams}Map<K, $clsName>.mutate(
                    mutation: ${MapMutatorName}<K, $clsName>.() -> Unit,
                ): Map<K, $clsName> = mutator().apply(mutation).get()
                
                
            """.trimIndent()
        )

        if (cls.isData()) {
            ctorFields.forEach { field ->
                when {
                    plugins.hasMutatorFieldGenerator(field) -> {
                        codeBlocks.addObjectMutatorField(cls, field)
                    }

                    else -> {
                        codeBlocks.addObjectPureField(cls, field)
                    }
                }
            }
        }
    }

    private fun isSupportedCollection(property: KSPropertyDeclaration, plugins: MutatorKspPlugins): Boolean {
        val type = property.type.resolve()
        val decl = type.declaration

        val collectionTypeParam = decl
            .takeIf { it.declaresKotlinList() || it.declaresKotlinSet() }
            ?.typeParameters?.firstOrNull()

        if (collectionTypeParam != null) {
            val boundType = GenericsUtil { type.boundTypeOf(collectionTypeParam) }

            return boundType != null && plugins.hasMutatorGenerator(boundType.declaration)
        }

        return false
    }

    private fun isSupportedMap(property: KSPropertyDeclaration, plugins: MutatorKspPlugins): Boolean {
        val type = property.type.resolve()
        val decl = type.declaration

        val mapValueTypeParam = decl
            .takeIf { it.declaresKotlinMap() }
            ?.typeParameters?.getOrNull(1)

        if (mapValueTypeParam != null) {
            val boundType = GenericsUtil { type.boundTypeOf(mapValueTypeParam) }

            return boundType != null && plugins.hasMutatorGenerator(boundType.declaration)
        }

        return false
    }
}
