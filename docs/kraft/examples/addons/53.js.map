{"version":3,"file":"53.js","mappings":"uFAAC,WAEA,GAAqB,oBAAVA,OAA6C,oBAAbC,SAA3C,CAKA,IAAIC,EAAW,wHAGXC,EAAY,8CAmEZC,EAAU,CArDd,SAAuBC,GACtB,IAAIC,EAAQH,EAAUI,KAAKF,GAC3B,GAAKC,EAAL,CAcA,IARA,IAAIE,GAHJH,EAAMC,EAAM,IAGWG,QAAU,EAAI,EAAI,EACrCC,EAAeL,EAAII,OAASD,EAG5BG,EAAwB,GAAhBH,EAAoB,EAAI,GAAK,EAAI,IAGzCI,EAAW,GACNC,EAAI,EAAGA,EAAIH,EAAcG,IAAK,CACtC,IAAIC,EAAMC,SAASV,EAAIW,OAAOH,EAAIL,EAAcA,GAAe,IAC/DI,EAASK,KAAKH,EAAMH,EACrB,CAWA,OAVoB,GAAhBD,GACHE,EAASK,KAAK,GASR,QALGL,EAASM,MAAM,EAAG,GAAGC,KAAI,SAAUC,GAC5C,OAAOC,OAAOC,KAAKC,MAAU,IAAJH,GAC1B,IAAGI,KAAK,KAGe,IAFXH,OAAOI,OAAOb,EAAS,GAAGc,QAAQ,KAET,GA1BrC,CA2BD,EAQA,SAAuBC,GACtB,IAAIC,GAAI,IAAIC,QAASC,MAErB,OADAF,EAAED,MAAQA,EACHC,EAAED,MAAQA,OAAQI,CAC1B,GAgBA/B,MAAMgC,MAAMC,IAAI,QAAQ,SAAUC,GACjC,GAAiB,UAAbA,EAAIC,MAAoBD,EAAIE,QAAQC,QAAQ,UAAY,EAAG,CAO9D,IANA,IAKIV,EALAW,EAAUJ,EAAII,QAGdC,EAAUD,EAAQE,MAAMtC,GAAUsB,KAAK,IAGlCX,EAAI,EAAG4B,EAAIrC,EAAQK,OAAQI,EAAI4B,IAAMd,EAAOd,IACpDc,EAAQvB,EAAQS,GAAG0B,GAGpB,IAAKZ,EACJ,OAGD,IAAIe,EAAiB,yFAA2Ff,EAAQ,oBACxHO,EAAII,QAAUI,EAAiBJ,CAChC,CACD,GAlGA,CAoGD,CAxGA,E","sources":["webpack://addons/../../node_modules/prismjs/plugins/inline-color/prism-inline-color.js"],"sourcesContent":["(function () {\n\n\tif (typeof Prism === 'undefined' || typeof document === 'undefined') {\n\t\treturn;\n\t}\n\n\t// Copied from the markup language definition\n\tvar HTML_TAG = /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/g;\n\n\t// a regex to validate hexadecimal colors\n\tvar HEX_COLOR = /^#?((?:[\\da-f]){3,4}|(?:[\\da-f]{2}){3,4})$/i;\n\n\t/**\n\t * Parses the given hexadecimal representation and returns the parsed RGBA color.\n\t *\n\t * If the format of the given string is invalid, `undefined` will be returned.\n\t * Valid formats are: `RGB`, `RGBA`, `RRGGBB`, and `RRGGBBAA`.\n\t *\n\t * Hexadecimal colors are parsed because they are not fully supported by older browsers, so converting them to\n\t * `rgba` functions improves browser compatibility.\n\t *\n\t * @param {string} hex\n\t * @returns {string | undefined}\n\t */\n\tfunction parseHexColor(hex) {\n\t\tvar match = HEX_COLOR.exec(hex);\n\t\tif (!match) {\n\t\t\treturn undefined;\n\t\t}\n\t\thex = match[1]; // removes the leading \"#\"\n\n\t\t// the width and number of channels\n\t\tvar channelWidth = hex.length >= 6 ? 2 : 1;\n\t\tvar channelCount = hex.length / channelWidth;\n\n\t\t// the scale used to normalize 4bit and 8bit values\n\t\tvar scale = channelWidth == 1 ? 1 / 15 : 1 / 255;\n\n\t\t// normalized RGBA channels\n\t\tvar channels = [];\n\t\tfor (var i = 0; i < channelCount; i++) {\n\t\t\tvar int = parseInt(hex.substr(i * channelWidth, channelWidth), 16);\n\t\t\tchannels.push(int * scale);\n\t\t}\n\t\tif (channelCount == 3) {\n\t\t\tchannels.push(1); // add alpha of 100%\n\t\t}\n\n\t\t// output\n\t\tvar rgb = channels.slice(0, 3).map(function (x) {\n\t\t\treturn String(Math.round(x * 255));\n\t\t}).join(',');\n\t\tvar alpha = String(Number(channels[3].toFixed(3))); // easy way to round 3 decimal places\n\n\t\treturn 'rgba(' + rgb + ',' + alpha + ')';\n\t}\n\n\t/**\n\t * Validates the given Color using the current browser's internal implementation.\n\t *\n\t * @param {string} color\n\t * @returns {string | undefined}\n\t */\n\tfunction validateColor(color) {\n\t\tvar s = new Option().style;\n\t\ts.color = color;\n\t\treturn s.color ? color : undefined;\n\t}\n\n\t/**\n\t * An array of function which parse a given string representation of a color.\n\t *\n\t * These parser serve as validators and as a layer of compatibility to support color formats which the browser\n\t * might not support natively.\n\t *\n\t * @type {((value: string) => (string|undefined))[]}\n\t */\n\tvar parsers = [\n\t\tparseHexColor,\n\t\tvalidateColor\n\t];\n\n\n\tPrism.hooks.add('wrap', function (env) {\n\t\tif (env.type === 'color' || env.classes.indexOf('color') >= 0) {\n\t\t\tvar content = env.content;\n\n\t\t\t// remove all HTML tags inside\n\t\t\tvar rawText = content.split(HTML_TAG).join('');\n\n\t\t\tvar color;\n\t\t\tfor (var i = 0, l = parsers.length; i < l && !color; i++) {\n\t\t\t\tcolor = parsers[i](rawText);\n\t\t\t}\n\n\t\t\tif (!color) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar previewElement = '<span class=\"inline-color-wrapper\"><span class=\"inline-color\" style=\"background-color:' + color + ';\"></span></span>';\n\t\t\tenv.content = previewElement + content;\n\t\t}\n\t});\n\n}());\n"],"names":["Prism","document","HTML_TAG","HEX_COLOR","parsers","hex","match","exec","channelWidth","length","channelCount","scale","channels","i","int","parseInt","substr","push","slice","map","x","String","Math","round","join","Number","toFixed","color","s","Option","style","undefined","hooks","add","env","type","classes","indexOf","content","rawText","split","l","previewElement"],"sourceRoot":""}